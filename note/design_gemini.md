# **Clojure-Dart-Wasmランタイム開発：技術的実現可能性と設計戦略**

## **1. エグゼクティブサマリー**

本報告書は、Dart言語とWebAssembly（Wasm）技術を基盤とした、新規Clojure処理系の開発に関する技術戦略を概説するものである。この処理系は、DartのWasmコンパイル機能（`dart2wasm`）を活用し、特にメモリ管理にはWasmGCを、再帰処理の最適化にはネイティブWasm末尾呼び出し最適化（TCO）の利用を前提とする。

中核的な設計思想として、Clojureのデータ型および基本操作をDartの構造体として表現し、これらをWasmの「コード片」またはモジュールとしてコンパイル・利用する点が挙げられる。これは、DartでClojureの全機能を再実装し、それを単純にWasmへコンパイルするアプローチとは異なり、より直接的なWasmへのマッピングを目指すものである。

さらに重要な点として、最終的に生成されるDart-Wasmランタイム自体がJust-In-Time（JIT）コンパイル機能を備え、実行時に入力されたClojureコードを効率的なWasmへと動的に変換することが構想されている。これにより、Clojureの動的な性質を維持しつつ、高性能なWasm実行を目標とする。

本プロジェクトは、SchemeからWasmへのコンパイラであるGuile Hootから着想を得ているが、実装言語としてのDartの選択、およびランタイムJITという野心的な要件により、独自のアプローチが必要となる。主要な課題としては、効果的なTCOの確保、永続データ構造に対するWasmGCの効率的な利用、そしてWasmホストされたDart環境内からのWasm生成の複雑性が挙げられる。Clojureの動的な特性、特に実行時の`eval`や強力なマクロシステムは、Wasmの主に静的な事前コンパイルモデルと調和させる上で中心的な課題となる。提案されているWasmランタイム内でのJITコンパイルは、この課題に対する最も野心的な側面であり、慎重なアーキテクチャ設計が求められる。Clojureのコードは実行時に評価され、マクロによって変換されるため、ランタイムがコード生成と変更の能力を持つ必要がある。Wasmは進化しているものの、基本的には事前コンパイルされたバイトコード形式である。ユーザーの目標を達成するためには、Dart-Wasmランタイムが実行時に効果的にコンパイラとして機能し、Clojureコードを新しいWasm構造に変換する必要がある。これは、モジュールがAOTコンパイルされる典型的なWasmのユースケースとは大きく異なる。

「DartにおけるClojureデータ型をWasmコード片として」という戦略は極めて重要である。これは、Clojureのデータ構造と操作を表すDartクラスが`dart2wasm`によってWasmGCオブジェクトと関数にAOTコンパイルされることを示唆している。ランタイムJITは、Clojureロジックを実行するために、これらの事前コンパイルされたWasmコンポーネントを編成することになる。この「リンキングJIT」または「構成JIT」アプローチは、Dart（それ自体がWasmにコンパイルされている）で完全なWasmバイトコードエミッタを実装するよりも実現可能性が高い。これにより、`dart2wasm`がプリミティブとデータ構造操作のためのDartからWasmGCへの変換という重労働を担い、ランタイムJITはより高レベルな構成と制御フロー生成に集中できるようになる。

## **2. Guile Hootからの基礎的洞察**

### **2.1. Guile HootのアーキテクチャとScheme-to-Wasmコンパイルの分析**

Guile HootはSpritely Instituteのプロジェクトであり、Scheme（当初はR7RS-small、最終的にはGuile全体を目指す）をWasmにコンパイルし、ブラウザや他のWasm GCランタイムでのScheme実行を可能にするものである **1**。これには完全なWasmツールチェインが含まれる **3**。Guileにおけるコンパイルパイプラインは、SchemeをTree-ILに、次に継続渡しスタイル（CPS）に低レベル化し、HootはこのCPSからWasmへのWasmバックエンドを追加する **6**。この多段階プロセスは、最適化コンパイラでは典型的である。

Hootはプログラム全体のコンパイルを採用しており、ユーザープログラムとすべてのインポートを単一ユニットとして分析し、1つのWasmバイナリを生成する。これにより「ツリーシェイキング」が容易になりバイナリサイズを最小化できるが、小さな変更でも再コンパイル時間が長くなる可能性がある **6**。David Thompson氏はGuile Hootの主要なエンジニアである **5**。FOSDEMのプレゼンテーション **7** では、Hootの機能と設計が詳述されている。

Guile Hootは、動的なLisp風言語をWasm上で実行する実現可能性を示す重要なリファレンスである。そのコンパイル戦略、特にCPSの使用は、関数型言語を実装し、TCOのような最適化を可能にするための確立された手法である。プログラム全体のコンパイルアプローチは、ウェブ展開サイズを最小化するための実用的な選択であり、本プロジェクトがウェブを主要ターゲットとする場合の考慮事項となる。Hoot自身のWasmツールチェインを含むHootの開発 **5** は、関連する作業が容易ではないことを強調している。動的言語はしばしば豊富な標準ライブラリを伴う。これらをウェブ配信（ダウンロードサイズが重要）に実用的にするためには、これらのライブラリの未使用部分を排除する必要がある。プログラム全体の分析は、モジュール間の依存関係が除去のために追跡困難な場合がある個別コンパイルと比較して、より効果的なデッドコード除去（ツリーシェイキング）を可能にする。本プロジェクトでは、この展開最適化と開発サイクルの速度とのバランスを考慮する必要がある。

### **2.2. 中間表現（CPS）とWasmへの変換**

HootのWasmバックエンドは、GuileのコンパイラタワーからのCPS IRを特にターゲットとしている **6**。Andy Wingo氏によるHootのWasmツールキットに関する議論 **5** は、変換を実行し、低レベルWasmランタイムライブラリへの呼び出しを発行するために、コンパイラ内Wasm表現の必要性を強調している。これは、CPSからWasmへの変換が単純な一対一のマッピングではなく、洗練されたプロセスであることを示唆している。Hootツールチェイン自体（WATパーサー、アセンブラ、逆アセンブラ、インタプリタ（David Thompson氏が実装）を含む）は、約10,000行のSchemeコードに及ぶ **5**。この投資により、Wasm生成とイントロスペクションに対するきめ細かい制御が可能になる。

ユーザーが問い合わせたHootのIRからWasmへの変換における「手作業」については、**5**によって、このようなツールチェインの構築はWasmをターゲットとするコンパイラにとって重要かつ価値のある取り組みであり、より良い最適化と言語固有機能の処理を可能にすると示唆されている。この「手作業」とは、高レベルのScheme構成要素（CPSで表現される）を、WasmGCや末尾呼び出しのような新しいWasm機能を効率的に活用する特定の最適化されたWasm命令シーケンスにマッピングするために必要な詳細なコンパイラエンジニアリングを指す。これはWasmモジュール全体を手書きすることではなく、Schemeのセマンティクス（クロージャ、継続、動的型付けなど）に対して特定の最適化されたWasm命令シーケンスを生成するコンパイラパスの設計と実装に関するものである。Hootのカスタムツールチェイン **5** は、このレベルの制御を容易にする。CPSは多くの分析と変換を単純化するIRであるが、Wasmに対しては依然として抽象的である。CPSをWasmにマッピングするには、WasmGCフレンドリーなランタイムデータ構造（例えばクロージャ用）の慎重な設計と、これらの構造を正しく操作しSchemeの制御フローを実装するWasmコードの生成が必要である。これはWasmのテキストエディタを使うような「手作業」ではなく、コンパイラのコード生成アルゴリズムを設計する知的な努力としての「手作業」である。

Guile HootがSchemeで独自の広範なWasmツールチェインを開発したという事実 **5**（Wasmインタプリタを含む）は、汎用的で既製のWasmコンパイラ（Dart用の`dart2wasm`など）だけに頼るのでは、高レベル動的言語のIR（Scheme用のCPSやClojure用の同様のIRなど）をWasmに最適にマッピングするための十分な制御や表現力が得られない可能性を示唆している。これは、ユーザーのプロジェクト、特にJITコンポーネントが、`dart2wasm`の直接出力よりも低いレベルでWasmに関与する必要があるかもしれないことを意味し、Dartでプログラム的にWasm構造を生成または操作することになる可能性がある。`dart2wasm`のような汎用コンパイラは、ソース言語（Dart）を効率的にコンパイルするように設計されている。それらは、そのソース言語（Dart内のClojure）によってエミュレートまたはJITコンパイルされる言語のセマンティクスを本質的に理解したり最適化したりしない場合がある。Hootチームは、Scheme構成要素用に生成されるWasmを正確に制御するために独自のツールを構築した。ユーザーの「Wasmコード片」という概念は、より直接的なWasm構築または構成の同様の必要性を示唆している。

### **2.3. HootにおけるWasmGCとネイティブ末尾呼び出しの活用**

Hootは、WasmGCや末尾呼び出しといったWasm拡張機能を明示的に利用している **2**。Wasm 1.0はGC依存言語には適していなかったため、これは極めて重要である **4**。Schemeの適切な末尾再帰の要件 **12** は、Wasmの`return_call`および`return_call_indirect`命令によって直接サポートされる **13**。Wasmにコンパイルされブラウザで実行されるHoot REPLは、WasmGCの実際の動作を示す実用的なデモンストレーションとして機能する **2**。最近のWebKitにおけるWasmGCと末尾呼び出しのサポート **8** は、Hootのブラウザ互換性を拡大する。

HootによるWasmGCとネイティブ末尾呼び出しの採用は、ユーザーの核となる技術戦略の妥当性を裏付けるものである。Hootにおけるこれらの機能の成功裏の実装は、肯定的な前例を提供する。しかし、これはまた、ブラウザや他のWasmランタイムにおけるこれらのWasm機能の継続的なサポートと成熟へのプロジェクトの依存性も浮き彫りにする。

### **2.4. Guile Hootと提案されるClojure-Dart-Wasmランタイムの比較**

以下の表は、Guile Hootと本提案のClojure-Dart-Wasmランタイムの主な特徴を比較したものである。

| **特徴** | **Guile Hoot** | **提案Clojure-Dart-Wasmランタイム** |
| --- | --- | --- |
| ソース言語 | Scheme | Clojure |
| 主要中間表現(群) | Tree-IL, CPS | Clojure AST, カスタムIR (例: CPS風) |
| Wasmバックエンド戦略 | GuileによるカスタムWasmバックエンド, Hoot Wasmツールチェイン | ランタイム用にDart `dart2wasm`, JIT用にDartによるカスタムWasm生成/リンキングロジック |
| ガベージコレクションアプローチ | WasmGC | WasmGC |
| 末尾呼び出し最適化ハンドリング | ネイティブWasm `return_call` | ネイティブWasm `return_call` (`dart2wasm`がサポートする場合)、そうでなければIRレベルTCO |
| コンパイラ/ランタイムの主要実装言語 | Guile Scheme | Dart |
| ソース言語のWasmへのランタイムJITコンパイル | いいえ (SchemeのWasmへのAOTコンパイル) | はい (ClojureからWasmへのJIT) |

この比較から、提案プロジェクトがHootに触発されつつも、実装言語（Dart対Guile Scheme）およびClojureからWasmへのランタイムJITコンパイルという主要な野心的目標（HootはSchemeに対してこれを行わない）において根本的に異なることが明確になる。Hootのソリューションが直接適用可能な領域（例：LispをWasmにコンパイルする一般的なアプローチ、WasmGC/TCOの使用）と、新規ソリューションが必要な領域を特定するのに役立つ。「ランタイムJIT」の行は両者を際立たせ、提案プロジェクトの主要な技術革新と課題を強調する。

## **3. 実装言語としてのDart：Wasmのための能力と考慮事項**

### **3.1. DartからWasmへのコンパイル（`dart2wasm`）**

`dart2wasm`は、WebAssemblyモジュールを生成するための公式Dartコンパイラであり、現在実験的ではあるが活発に開発されている機能である **14**。これはDart SDKの一部である。コンパイルプロセスは多段階である **17**。

1. 共通Dartフロントエンド：パース、型チェック、低レベル言語機能。
2. 型フロー分析：ASTレベルの最適化（定数伝播、ツリーシェイキング）、Dart Native AOTと共有。
3. 表現フェーズ：Dart型からWasmインタプリタ互換型への変換（例：Dart StringからWasm Stringへ、複雑な型のボクシング/アンボクシング）。これはWasmGC統合にとって重要なフェーズである。
4. コード生成：実際のWasm命令の生成。LLVMベースのコンパイラとは異なり、このフェーズは直接Wasmを生成する。
5. Binaryen：出力を洗練するために使用されるスタンドアロンのWasm-to-Wasmオプティマイザ。

アサーション、関数エクスポート、インライン化、JS互換性、型チェックの省略、中間ステップの表示など、側面を制御するための包括的なコンパイラオプションセットが提供されている **14**。

`dart2wasm`パイプライン、特に「表現フェーズ」と「コード生成」を徹底的に理解することが不可欠である。これらの段階は、Dartクラス（Clojureのデータ/操作をモデル化する）がどのようにWasmGCオブジェクトと実行可能なWasm関数に変換されるかを決定する。Binaryenの使用 **17** は、最適化されたWasmを生成するための標準である。利用可能なコンパイラフラグ **14** は、DartベースのClojureランタイムのパフォーマンス調整とデバッグに不可欠となる。

以下に、`dart2wasm`の主要なコンパイラオプションと、Clojureランタイム開発への関連性を示す。

| **オプション** | **デフォルト** | **説明** | **Clojureランタイムへの関連性** |
| --- | --- | --- | --- |
| `--[no-]enable-asserts` | no | 実行時のアサーションを有効/無効にする。 | デバッグの容易性、本番ビルドでは無効化してパフォーマンス向上。 |
| `--[no-]export-all` | no | 全ての関数をエクスポートするか、`main`のみをエクスポートするかを決定する。 | ランタイムの内部関数を隠蔽し、公開APIのみをエクスポートするのに有用。 |
| `--[no-]inlining` | yes | 関数のインライン化を有効/無効にする。 | パフォーマンスに影響。インライン化は一般的に高速化に寄与するが、コードサイズが増加する可能性。 |
| `--inlining-limit size` | 0 | インライン化が有効な場合、常にインライン化される関数の最大サイズ（ASTノード数）。 | 特定の小さなヘルパー関数のインライン化を強制するのに使用可能。 |
| `--[no-]js-compatibility` | no | JavaScript互換モードを有効/無効にする。 | 主にJSとの相互運用性に関連。本プロジェクトではWasmネイティブ機能を優先するため、通常は無効。 |
| `--[no-]omit-type-checks` | no | 共変性チェックやダウンキャストなどの実行時型チェックの省略を有効/無効にする。 | パフォーマンス向上の可能性があるが、型安全性が低下するリスク。Clojureの動的性をDartで表現する際に型チェックのオーバーヘッドが問題になる場合に検討。 |
| `--[no-]polymorphic-specialization` | no | クラスIDによるスイッチングで仮想呼び出しを行うか、`call_indirect`を使用するか。 | Dartオブジェクトのメソッド呼び出しのWasmレベルでの実装方法に影響。パフォーマンス特性を評価する必要あり。 |
| `--[no-]print-kernel` / `--[no-]print-wasm` | no | 各関数のIR / Wasm命令をコンパイル前に表示する。 | `dart2wasm`がDartコードをどのようにWasmに変換しているかを理解し、デバッグするのに非常に有用。 |

### **3.2. WasmGC統合：Dart型からWasmGC型へのマッピング**

DartのWasmコンパイルは明示的にWasmGCをターゲットとしており、DartオブジェクトをホストVMのガベージコレクタによって管理できるようにし、それによって別のGCをバンドルする必要性を回避する **16**。`dart2wasm`の「表現フェーズ」がこの型マッピングを担当する **17**。例えば、Dartの`String`はWasmの文字列表現に変換され、複雑な型はボックス化またはアンボックス化されることがある。Wasmを介したJS相互運用の場合、Dartの`double`はWasmの数値にマッピングされ、JSオブジェクトは`JSAny`（Wasmの`externref`にマッピング）として扱われ、Dartオブジェクトは`anyref`として発行され、Wasm境界で自動的に変換される **14**。WasmGCは`struct`および`array`ヒープ型を導入し、非線形メモリアロケーションを容易にし、管理言語のオブジェクトに対する効率的なフィールドアクセスを可能にする **18**。これは、Dart（ひいてはClojure）のような言語からの構造化データを表現する上で鍵となる。

WasmGCはプロジェクトの実現可能性の基礎である。Dartオブジェクト（Clojureのデータ構造と関数をモデル化する）がWasmGCオブジェクトにマッピングされる効率は、パフォーマンスに大きく影響する。`anyref`型は、Wasm境界を越えてDartオブジェクトを渡すために不可欠である。WasmGCの`struct`および`array`型は、Wasmヒープ内でClojureのコレクションを表現するための構成要素となる。`dart2wasm`がDart型をWasm型にマッピングする「表現フェーズ」**17** は極めて重要である。ユーザーの「Clojureデータ型をDartで表現し、それをWasmコード片として活用する」というアイデアは、これらのDart表現が、このフェーズによってWasmGCの構造体や配列に最適に変換されるように設計されなければならないことを意味する。Dartの設計が不適切だと、WasmGCオブジェクトのレイアウトが非効率になったり、過度なボクシング/アンボクシングが発生したりする可能性がある。

### **3.3. `dart2wasm`における末尾呼び出し最適化（TCO）**

WebAssembly自体には、`return_call`および`return_call_indirect`命令によるネイティブ末尾呼び出し提案があり、これは関数型プログラミングパターンの最適化に不可欠である **13**。この機能は現在、主要ブラウザで「Baseline Newly available」と見なされている **19**。歴史的に、Dart言語はTCOを保証してこなかった。主な理由として、Dartの初期のウェブターゲットであったJavaScriptへのTCOの効率的なコンパイルの難しさが挙げられていた **21**。

提供された調査資料では、`dart2wasm`が現在、一般的なDartの再帰関数に対してWasmの`return_call`命令を確実に発行することでTCOを実行するという**明確な確認は得られていない**。TCOに関するDart SDK GitHubイシュー#29は非常に古く（2011年開設 **23**）、その議論は主に現代のWasm TCO機能以前のもので、JSに焦点が当てられていた。`dart-lang/sdk`における最近（2023年以降）のイシューで、`dart2wasm`、TCO、または`return_call`を関連付ける具体的な設計文書や活発な実装イシューは、提供された資料からは見つからなかった（**70**、**71**、**72**、**73**、**74**はアクセス不可だったが、他の利用可能なデータに基づくとこれが予想される結果である）。ScalaやClojure（JVM上）のような言語は、基盤となるプラットフォームがネイティブサポートを欠く場合、コンパイラ変換（例えば、末尾再帰をループに変換したり、トランポリンを使用したりする）を通じてTCOを実装している **22**。これはここで必要な戦略かもしれない。Wasm末尾呼び出しに関するV8ブログ **13** はWasm命令を詳述しているが、Dartによるそれらの特定の利用については議論していない。FermyonのWasm用Dartに関するページ **24** はDartチームとChromeチームによる活発な開発に言及しているが、TCOについては詳述していない。

これは重大なリスク領域である。Clojureは再帰に大きく依存している。もし`dart2wasm`がDartの再帰パターンに対してWasmの`return_call`へのTCOを確実に行わない場合、Dartで実装されたClojureランタイムは、深い再帰に対してスタックオーバーフローに悩まされるか、DartコードがWasmにコンパイルされる前に独自のTCOメカニズム（例えばトランポリン）を実装する必要がある。これは複雑さを増す。DartのTCOに関する歴史的な立場（JSコンパイルの制約により保証しない **21**）は、WasmコンパイルされたClojureランタイムにおいてDartにTCOを依存することの実現可能性に直接影響する。WasmがTCOをサポートしていても、`dart2wasm`が全てのDart再帰パターンに対してそれを完全に活用しない可能性がある。このことは、ユーザーのプロジェクトがClojureコードに対するTCOをDartで表現する前、あるいはDart表現自体がトランポリンのような技術を使用しなければならない可能性が高いことを示唆している。あるターゲット（JS）のために行われた言語設計の決定は、他のターゲット（Wasm）に持続的な影響を与える可能性がある。Dart言語とそのコアコンパイラが保証されたTCOを基本的な最適化として構築されていない場合、`dart2wasm`がそれを完全に、特にClojureを表現することから生じるかもしれない全ての慣用的なDartコードパターンに対して後付けする可能性は低い。ClojureセマンティクスのためのTCOの負担は、おそらくClojureからDartへの変換レイヤーにかかることになるだろう。

### **3.4. Dart-Wasm相互運用性：関数のインポート/エクスポート、JS相互運用**

Dart関数は`@pragma("wasm:export")`を使用してWasmにエクスポートでき、ホスト関数は`@pragma("wasm:import")`を使用してインポートできる **14**。Wasmコンパイルのために、Dartは新しいJS相互運用メカニズムに移行した：`package:web`（`dart:html`を置き換える）および`dart:js_interop`（`package:js`、`dart:js`を置き換える）**16**。古いJS相互運用ライブラリはWasm互換ではない。DartのWasm出力は現在JavaScript環境をターゲットとしており、Wasmtime/WasmerのようなスタンドアロンWasmランタイムを直接サポートしていない **16** が、WASIサポートは提案段階である **26**。

新しいJS相互運用は不可欠である。Wasm出力の現在のJavaScript環境へのターゲティング制限は、ブラウザベースの実行には許容できるかもしれないが、非ブラウザWasmランタイムが将来的に構想される場合には要因となる可能性がある。しかし、プロジェクトの核心は、Wasmランタイム自体がClojureコードをJITコンパイルすることであり、これはランタイム自身のコードに対するこのホスト相互運用とは独立して行われる可能性がある。Dartの現在のWasm出力がJS環境をターゲットとしていること **16**、およびWASI/コンポーネントモデルサポートに関する進行中の作業 **26** は、「自己完結型」のJITコンパイルされたClojure-Wasmモジュール（ランタイムによって生成される）が、ホストとの相互作用のために当初はDart-WasmランタイムのJS相互運用レイヤーに依存することを意味する。非ブラウザWasmランタイムでの真のスタンドアロン実行は将来的な懸念事項であるが、それが長期的な目標である場合にはアーキテクチャの選択に影響を与える可能性がある。

## **4. Clojure-in-Dart-to-Wasmランタイムのアーキテクチャ設計**

### **4.1. コアClojureサブセットの定義**

初期の焦点は、最小限でありながら機能的なClojureのサブセットに置かれるべきである。不可欠なデータ構造には、数値（long、double、BigInt、Ratio）、文字列、シンボル、キーワード、リスト、ベクタ、マップ、セットが含まれる **27**。コア関数には、基本的な算術演算、比較、論理演算、`if`、`let`、`fn`、`def`、`loop`/`recur`、シーケンス操作（map、filter、reduce、conj、first、restなど）が含まれる **28**。不変性と永続性はClojureの中核的な信条である **27**。プロジェクトは、Java相互運用性や内部Javaデータ構造を完全に複製する必要はないと明示的に述べている（ユーザーからの質問）。例えば、Jank言語も最小限のランタイムでClojureセマンティクスを目指しており、段階的型付けやより明示的なメモリ管理などの潜在的な改善点を提供している **30**。

明確に定義されたサブセットから始めることは、複雑さを管理する上で極めて重要である。リストされたデータ構造と関数は、ほとんどのClojureプログラムの基盤を形成する。詳細なJava相互運用を除外するという決定は、タスクを大幅に簡素化し、Wasm上でのコアLispおよびClojureセマンティクスに集中することを可能にする。

### **4.2. WasmGCのためのDartにおけるClojureデータ構造の表現**

Clojureのコレクションは不変かつ永続的であり、しばしば構造共有を利用する **27**。ハッシュ配列マップトライ（HAMT）はマップやセットに一般的であり、永続ベクタもツリー状の構造を使用する。Dart自体には、Flutterの基盤ライブラリに`PersistentHashMap`があり、これはClojureのものに触発され、HAMTの変種を使用している **32**。これは直接的な参照またはインスピレーションの源となり得る。`fast_immutable_collections` **33** は、不変コレクションを提供する別のDartライブラリであり、異なるパフォーマンストレードオフを持つ可能性がある。

Clojure型のためのDartクラスを設計する際には、以下の点を考慮する。

- WasmGCフレンドリーなレイアウトを目指す：可能な限り構造体と配列を優先する。
- オブジェクト割り当てパターンを考慮する。WasmGCはホストGCとの統合によって役立つが、永続データ構造のための多数の小さなオブジェクトの頻繁な割り当て/解放は依然としてオーバーヘッドを持つ可能性がある 。

    **18**

- Dartクラス設計のベストプラクティスに従う 。

    **36**

ユーザーのアイデア：「Clojureのデータ型をDartのデータ型で再現し、それをwasmコード片やモジュールとして活用する」。これは、Clojure型を表すDartクラスが`dart2wasm`によってWasmGC型にコンパイルされ、これらのDartクラスのメソッドがこれらのWasmGC型を操作するWasm関数になることを意味する。

これはプロジェクトの基礎である。Clojureの永続データ構造をDartで効率的に実装し、それらがパフォーマンスの高いWasmGC表現にコンパイルされるようにすることが鍵となる。Flutterの`PersistentHashMap` **32** は非常に強力な前例であり、潜在的な出発点である。これらの構造のWasmGC上でのパフォーマンスは未解決の問題である。WasmGCはメモリ管理を処理するが、WasmGC下での構造共有の効率と結果として生じるオブジェクトグラフは慎重な検討が必要である。「Wasmコード片」というアイデアは、これらのDart-Clojure型に対する操作（例えば、ベクタに対する`conj`）が、JITが呼び出すことができるWasm関数にコンパイルされたDartメソッドであることを示唆している。

Flutterの`PersistentHashMap` **32** は、Clojureに触発されDartで実装されており、本プロジェクトにおけるClojureのコア不変マップをDartで実装するための非常に適切な、実証済みの出発点を提供する。その内部HAMT構造は、永続性と構造共有に適している。これをWasmGCに適応させ、そのメソッドが`dart2wasm`を介して効率的にコンパイルされるようにすることは、重要なステップとなるだろう。

以下に、Clojureデータ型のDart/WasmGCへのマッピング案を示す。

| **Clojure型** | **提案Dartクラス/表現** | **Dartでの主要実装戦略** | **想定WasmGCマッピング** | **パフォーマンス考慮事項** |
| --- | --- | --- | --- | --- |
| `PersistentVector` | `DartClojureVector` | ベクタ要素用のバッキング配列（おそらくチャンク化トライ） | Wasm配列 (`anyref`の) または構造体のツリー | 割り当てパターン、構造共有効率、アクセス速度 |
| `PersistentHashMap` | `DartClojureHashMap` **32** | HAMTノード | HAMTノード用のWasm構造体 | ハッシュ衝突、ロードファクタ、イテレーション効率 |
| `PersistentList` | `DartClojureList` | おそらくコンスセルベースのリンクリスト、または小さなリスト用の配列バック | コンスセル用のWasm構造体、または`anyref`のWasm配列 | `cons`/`first`/`rest`の効率、スタック消費（TCOが重要） |
| `Symbol` | `DartClojureSymbol` | 文字列（名前空間と名前）、キャッシュされたハッシュコード | 文字列フィールドを持つWasm構造体 | シンボルインターニングの効率、比較速度 |
| `Keyword` | `DartClojureKeyword` | `DartClojureSymbol`と同様 | `DartClojureSymbol`と同様 | キーワードインターニングの効率、比較速度 |
| `Integer` (Arbitrary) | `BigInt` (Dartネイティブ) | Dartの`BigInt`実装 | WasmGC `struct` (Dartの`BigInt`がそうマッピングされる場合) | `BigInt`操作のDartからWasmへのコンパイル効率 |
| `Double` | `double` (Dartネイティブ) | Dartの`double` | Wasm `f64` | 直接マッピング、高効率 |
| `Ratio` | `DartClojureRatio` | 2つの`BigInt`（分子と分母） | 2つの`BigInt`フィールドを持つWasm構造体 | 正規化、算術演算の効率 |
| `String` | `String` (Dartネイティブ) | Dartの`String` | Wasm `stringref` または同等のGC管理文字列型 | Dart文字列操作のWasmへのコンパイル効率、JS相互運用時の変換オーバーヘッド |

### **4.3. Clojureコード用中間表現（IR）**

ユーザーはWasm生成前の最適化のためにIRを挟むことに前向きである。Guile HootはTree-ILを使用し、次にCPSを使用する **6**。CPSは関数型言語に適しており、TCO、クロージャ変換、インライン化などの最適化を可能にする。IRは以下のように設計されるべきである。

1. Clojureセマンティクス（マクロ展開後を含む）を忠実に表現する。
2. Clojure固有の最適化（例：定数畳み込み、デッドコード除去、Clojure関数のインライン化）を容易にする。
3. Wasmへの低レベル化が比較的簡単であること（Dart表現または直接Wasm命令を介して）。

IRは強く推奨される。Clojure固有のAST（抽象構文木）がパース後の最初のステップとなるだろう。このASTは、Hootと同様に、Wasm生成の準備のためにCPS風のIRに低レベル化される可能性がある。このIRは、Dart-Wasmランタイム内のJITコンパイラによって操作される。

### **4.4. Dart-Wasmランタイム内でのClojureからWasmへのJITコンパイル**

### **4.4.1. `eval`の実装：ClojureフォームのWasmへのオンザフライコンパイル**

Clojureにおける`eval`は、フォームのパース、マクロ展開、コンパイル（必要な場合）、そして実行を含む **38**。本プロジェクトでは、`eval`は以下を行う。

1. 入力されたClojureコード（文字列またはデータ構造）を内部Clojure ASTにパースする（Dartで書かれたパーサーを使用）。
2. マクロ展開を実行する（次節参照）。
3. 展開されたClojure ASTをプロジェクトのIRに変換する。
4. IRを最適化する。
5. IRからWasmコードを生成する。これが最も複雑なステップである。
    - オプションA：Dartコードを動的に生成し、その後何らかの方法で実行時に`dart2wasm`を呼び出す（非常に複雑で、コンパイラの可用性と権限のため、ブラウザWasmサンドボックス内ではおそらく実現不可能）。
    - オプションB（より実現可能、ユーザーの「Wasmコード片」と整合）：Dart-Wasmランタイム自体が、Wasmバイトコードを直接発行するか、事前定義されたWasm「テンプレート」（Clojure操作/データ構造のDart表現から派生）をアセンブルするロジック（Dartで書かれ、Wasmにコンパイルされる）を含む。

生成されたWasm関数/モジュールは、Dart-Clojureランタイム自体が実行されているWasmランタイム環境によってロードおよび実行される必要がある。これは、Wasm環境が動的Wasmモジュールインスタンス化をサポートする必要があることを意味する **39**。Whammプロジェクト **40** は、Wasmバイナリモジュールを計測/変更するためのRustライブラリ（Seal）を示しており、これは動的コード生成/変更に関連するが、Sealは計測用であり、ゼロからの完全なJITコンパイル用ではない。

これは最も野心的な部分である。Wasmモジュール（Dart-Clojureランタイム）内からWasmへのJITコンパイルは最先端である。オプションBがより現実的である。Dartコードは、Wasmにコンパイルされると、Wasmジェネレータとして機能する。これは、Dartコードが有効なWasmバイトシーケンスまたはWasmモジュール構造をプログラム的に構築できる必要があることを意味する。WasmへのJITコンパイル（ユーザーからの質問）という願望は、それ自体がWasm（Dartからコンパイル）として実行されるランタイム内で発生するため、重大な技術的ハードルを生み出す：Wasm内からのWasm生成。標準Dartは、直接的なWasmバイトコード発行ライブラリを提供していない（言及がないことから推測、**75**）。これにより、DartでWasmアセンブラを実装する（複雑）か、事前コンパイルされたWasm「コード片」（`dart2wasm` AOTコンパイルを介したClojureプリミティブ/データ構造のDart実装から派生）を「リンク」する戦略を採用するかの選択を迫られる。後者はユーザーの表現とより整合性があり、初期にはより実現可能である。完全なJITは通常、パース、意味解析、IR生成、最適化、コード生成を含む。最終的なコード生成ステップ（Wasmバイトコードの発行）を、既にWasmであるDartコードから行うには、Dart-WasmランタイムがWasmアセンブラの機能を持つ必要がある。これは重要な作業である。「コード片」というアイデアは、Clojure操作を表すDartクラスが`dart2wasm`によって一度コンパイルされ、ランタイムJITが必要に応じてこれらのWasm関数/データ構造をインスタンス化してリンクすることを意味し、Clojureフォームごとにゼロから生のWasm命令を生成するのではない。

### **4.4.2. Clojureマクロの処理：非JIT、Wasm中心環境での展開戦略**

Clojureマクロは、コンパイル時にコード（データ構造）を変換する関数である **41**。それらは未評価のフォームを受け取る。`macroexpand` / `macroexpand-1`は展開を見るために使用される **44**。本プロジェクトでは、マクロはClojureコードがIRに変換され、その後Wasmに変換される前に展開されなければならない。マクロ展開ロジック自体（Clojureコードである）を実行する必要がある。これは、Clojureランタイムが、マクロ展開関数自体に対して、少なくともClojureのサブセット（マクロ定義を含む）を解釈的に、またはJITへの再帰呼び出しを介して実行できる必要があることを意味する。シンタックスクオート（```）とアンクオート（`~`）はマクロ記述の中心である **41**。これらはClojureパーサー/リーダーおよびマクロ展開エンジンによって処理される必要がある。

マクロ展開はDart-Clojureランタイム内で発生する必要がある。マクロは単なるClojure関数であるため、ランタイムはマクロ関数自体を実行するために`eval`機能（この段階ではWasmを生成しない単純なインタプリタであってもよい）を必要とする。このマクロ展開`eval`の出力（Clojureデータである）が、メインのWasm生成JITに供給される。これによりブートストラップの課題が生じる：`eval`はマクロを必要とし、マクロは`eval`を必要とする。Clojureマクロ **41** の実装には、マクロがコードを変換するClojure関数であるため、`eval`メカニズムが必要である。マクロ用のこの`eval`は、完全なWasm生成JITである必要はないかもしれない。Dart-Wasmランタイム内で実行されるClojureのサブセット（マクロ実行に十分）用の単純なインタプリタで十分かもしれない。このマクロ展開`eval`（Clojureデータである）の出力は、その後メインのWasm生成JITに供給される。

### **4.4.3. DartからのプログラムによるWasm生成：実現可能性の評価**

Dart内から直接Wasmバイトコードを生成または操作するための標準Dartライブラリは、資料には記載されていない（**75**はアクセス不可だが、このような検索が関連する）。Dartの`dart2wasm`はDartをWasmにコンパイルする **14**。プロジェクトは、Dart-ClojureランタイムがDartコード文字列を動的に構築し、その後（仮説的に）`dart2wasm`を呼び出すことでこれを活用できるかもしれない。これはJITには遅すぎて複雑すぎる可能性が高い。より現実的には、Dartコード（それ自体がWasmにコンパイルされる）がWasm発行ロジックを実装する必要があるだろう。これは、Wasm命令、セクション（型、関数、コード、エクスポートなど）、およびモジュールヘッダーに対応するバイトを書き込むことができるDart関数を持つことを意味する。あるいは、共通のClojure操作（Dartで実装）を小さく再利用可能なWasmモジュール/関数に事前コンパイルする。JITはその後、「リンキングJIT」として機能し、これらの事前コンパイルされたWasm片をアセンブルする。これはユーザーの「wasmコード片やモジュールとして活用する」という考え方と一致する。Flutterの`skwasm`レンダラ **46** は、Dartで使用されるWasmにコンパイルされたコンパクトなSkiaである。DartからWasmを生成するわけではないが、Dartが複雑なWasmモジュールと統合することを示している。`wasm_ffi`パッケージ **47** はDartがWasmモジュールを呼び出すことを可能にするが、生成はしない。

Dartからの直接的なWasmバイトコード発行（それ自体がWasmとして実行されている）は、JITにとって最も柔軟性があるが、最も複雑なアプローチでもある。DartでWasmアセンブラのかなりの部分を実装する必要がある。「リンキングJIT」アプローチは、DartプリミティブのClojure実装から派生した事前コンパイル済みWasm片を使用し、初期にはより管理しやすいように思われる。この戦略は、Clojure型を表すDartクラスとそのメソッドが`dart2wasm`によってAOTコンパイルされてWasmビルディングブロックになり、JITがそれらを結び付けることを意味する。

## **5. プロジェクト設定と初期実装ステップ**

### **5.1. Wasm開発のためのDart環境設定**

Dart SDKをインストールする（null安全性のためにバージョン >= 2.12、`dart2wasm`はより新しいので最新の安定版を確認）**48**。Wasm出力には`dart compile wasm`を使用する **16**。`dart2wasm`オプションに習熟する **14**。ウェブ展開の場合、WasmモジュールをロードするためにJSブートストラップファイルが必要になる **16**。複雑なウェブアプリをビルドする場合は`build_web_compilers`を検討するが、コアランタイムは初期にはより単純なWasmモジュールかもしれない **50**。

標準的なDart設定が出発点である。重要なのは、`dart compile wasm`パスウェイに焦点を当て、その出力と要件（ブラウザ用のJSローダーなど）を理解することである。

### **5.2. Dartにおける基本的なClojureパーサー/リーダーの概要**

Clojureのリテラルデータ構造（リスト、ベクタ、マップ、セット、シンボル、キーワード、文字列、数値）を対応するDart表現にパースできるリーダーを実装する。Clojureのリーダーマクロ（例：`'`、`` ````、`~`、`~@`、`#()`、`#{}`）を処理する。このパーサーは`eval`プロセスの基本的な部分となる。

堅牢なパーサーは、あらゆる言語実装の第一歩である。Dartで書かれたこのパーサーは、マクロ展開器とJITが消費するASTを生成する。

### **5.3. DartにおけるコアClojureデータ構造の初期実装スケッチ**

必要であれば、まず単純な非永続バージョンから始め、次に永続バージョンに進化させる。例：`DartClojureSymbol`クラス、`DartClojureKeyword`クラス。基本的な`DartClojureList`（初期にはDartの`List`でバックアップされるなど）。これらの型が公開する必要のあるインターフェース（例：`first`、`rest`、`conj`用）に焦点を当てる。

Clojure型をモデル化するDartクラスの実装を開始する。これは、「DartにおけるClojureデータ型をWasmコード片として」という戦略に直接つながる。

### **5.4. Wasm生成をターゲットとした初歩的な`eval`ループの構造**

パースされたClojureフォーム（Dartオブジェクトとして）を取る単純化された`eval`。初期には、いくつかの特殊形式（例：`if`、`def`）を直接解釈するかもしれない。関数呼び出しの場合、事前コンパイルされたWasm関数（Dart実装から派生）を検索し、呼び出しを調整する。この初期の`eval`は完全なJITではないが、Dartから生成されたWasmコードへのディスパッチ方法を理解するための基礎を築く。

これはJITの制御フローのスケッチに関するものである。Clojureコードを受け取り、それをWasm関数の実行にどのようにマッピングするのか？たとえそれらのWasm関数が初期にはAOTコンパイルされたDartメソッドであってもである。JITコンパイルの複雑さと永続データ構造の実装は、段階的なアプローチを示唆している。フェーズ1：Dartでの堅牢なClojureパーサー。フェーズ2：Clojureデータ型のDart表現（最初は可変、次に永続的、**32**を活用）。フェーズ3：Clojureサブセット用のDartインタプリタ。フェーズ4：このDartインタプリタとデータ構造を`dart2wasm`を使用してWasmにコンパイル。フェーズ5：解釈された部分をJIT生成されたWasm片で徐々に置き換える。一度にすべての困難な問題（永続性、WasmへのJIT、マクロ）に取り組むのは危険である。段階的なアプローチにより、漸進的な進捗と検証が可能になる。Dartで実行される基本的なClojureインタプリタを取得し、それをWasmにコンパイルすることで、JITコンパイルされたWasmで解釈実行パスを置き換えることによって反復的に最適化できる作業システムが提供される。

「Dart-Wasmランタイム内でのClojureからWasmへのJITコンパイル」（ユーザーからの質問）は、Dartコード（ランタイムWasmモジュールとなる）が、(a) Wasmバイトコード配列を直接構築できるか、(b) バイトコードからの動的モジュールロード/リンキングを可能にする何らかのWasmランタイムAPIと対話できる必要があることを意味する。標準Dartには組み込みのWasmアセンブラライブラリがない。これは早期に解決すべき主要な実装の詳細である。JITが実行時に新しいWasmコードを生成する場合、WasmにコンパイルされたDartコードはそのための手段を持たなければならない。これはDartがそれ自体をWasmにコンパイルすること（それは`dart2wasm`の仕事）ではなく、結果として得られるWasmプログラムがさらにWasmを生成することに関するものである。この機能は、Wasmツールチェインとして特別に設計されていない限り、ほとんどの言語ランタイムでは標準ではない。「Wasmコード片」戦略は、これらの片をDartから事前コンパイルし、JITをリンカ/ディスパッチャのように動作させることで、これを緩和する。

## **6. 高度なWasmエコシステム機能の活用**

### **6.1. Wasm例外処理**

Wasmには現在、例外処理提案があり、WasmモジュールがJavaScript例外とも相互運用可能な例外をスローおよびキャッチできるようにする（**54**はブラウザサポートを示す）。これは、ClojureランタイムおよびJITコンパイルされたコードにおける堅牢なエラー処理にとって重要である。`dart2wasm`がDart例外をWasm例外に、またその逆にどのようにマッピングするかを調査する必要がある。

ネイティブWasm EHは、手動のエラーコード渡しよりも望ましい。Clojureランタイムは、Clojure例外がこのシステムにどのようにマッピングされるかを定義する必要がある。

### **6.2. 型付き関数参照**

Wasm型付き関数参照により、関数を型チェックされたファーストクラスの値として渡すことができ、整数テーブルインデックスによる`call_indirect`よりも効率的で安全な間接呼び出しが可能になる（**54**はブラウザサポートを示す）。これは、関数がファーストクラスであるClojureのような関数型言語に非常に関連性がある。DartのWasmコンパイルは、Dart関数オブジェクトに対してこれを活用する可能性がある。これが、（Dartで表現された）Clojure関数がWasmにJITコンパイルされる際にどのように変換されるかを探求する必要がある。

このWasm機能は、Clojure関数（WasmにJITコンパイルされた後）の呼び出しのパフォーマンスと型安全性を大幅に向上させる可能性がある。これは、関数ポインタ/参照を処理するためのより直接的な方法である。

### **6.3. Wasmコンポーネントモデル**

コンポーネントモデルは、高レベルのインターフェース型システム（WIT）を定義することにより、異なる言語で書かれたWasmモジュール間の相互運用性を可能にすることを目指している **20**。Dartのコンポーネントモデル/WASIサポート計画は初期段階/提案段階である **26**。これは、Clojure-Wasmランタイムを他のWasmコンポーネントと相互運用するための将来的な考慮事項であり、当面のコア実装の懸念事項ではない。

これは初期バージョンには不可欠ではないが、コンポーネントモデルの認識は、将来の保証とより広範なWasmエコシステムとの潜在的な統合にとって重要である。

### **6.4. 動的Wasmモジュールローディング**

JITコンパイルアプローチ（実行時にWasmを生成する）は、これらの新しく生成されたWasmモジュール/関数を実行中のWasm環境にロードおよびリンクする機能を必要とする。Wasm MVPは、ホスト固有の機能（例：JS API `WebAssembly.instantiate`）を介してこれを可能にする **39**。Dart-Wasmランタイムは、JITコンパイルされたWasmをロードするために、これらのホスト機能（おそらくDartのJS相互運用を介して）と対話する必要がある。Dartの動的コードローディングに関する歴史的な問題 **53** は異なるコンテキスト（Dart VMであり、Wasm JITではない）であったが、複雑さを浮き彫りにしている。

JITは、生成するコードを実行可能にする方法を必要とする。ブラウザでは、これはWasmバイトコードをコンパイルおよびインスタンス化するためにJS APIを使用することを意味する。Dart-Wasmランタイムは、そのような機能を公開または使用する必要がある。

プロジェクトの潜在能力全体、特にJITコンパイルされたClojureコードのパフォーマンスと堅牢なエラー処理に関しては、`dart2wasm`とターゲットWasmランタイム（ブラウザ）の両方における型付き関数参照やWasm例外処理などの高度なWasm機能の成熟度と一貫した実装にかかっている。これらの機能はWasmへの比較的新しい追加である。サポートは拡大しているが **54**、`dart2wasm`のようなコンパイラによるそれらの最適な使用には時間がかかる。もし`dart2wasm`がClojureランタイムのDartコードによって生成されるパターンに対してまだそれらを完全に活用していない場合、利点は遅れるか、それらを模倣するために手動のWasm「コード片」設計が必要になる可能性がある。

Wasmコンポーネントモデル **20** は、Clojure-Wasm-within-Dart-Wasmという内部JITにはすぐには不可欠ではないが、Wasm相互運用性の将来の方向性を示している。Clojureランタイムの外部API（もしあれば、`eval`以外）をコンポーネントライクなインターフェース思考で設計することは、将来の統合を容易にする可能性がある。コンポーネントモデルはWasmモジュールの相互運用性を解決することを目指している。もしClojure-Wasmランタイムが将来的に再利用可能なコンポーネント自体になること、または他のWasmコンポーネントを消費することを意図している場合、これらの新しい標準に合わせることが有益となるだろう。これは長期的なアーキテクチャ上の考慮事項である。

以下に、Dartおよび主要ブラウザにおける高度なWasm機能のサポート状況と、本プロジェクトへの影響を示す。

| **機能** | **dart2wasmの現在のサポート/使用状況** | **主要ブラウザサポート (Chrome, Firefox, Safari)** | **Clojure-Dart-Wasmへの影響** |
| --- | --- | --- | --- |
| WasmGC | はい (主要ターゲット) **16** | Chrome 119+, Firefox 120+, Safari 18.2+ (WebKit) | GCに不可欠。Dartオブジェクトの効率的な管理。 |
| ネイティブ末尾呼び出し | 不明/未確認 (Wasm `return_call`の直接生成) | Chrome 112+, Firefox 120+, Safari 18.2+ (WebKit) | 再帰のパフォーマンスに極めて重要。DartレベルでのTCOまたはIRレベルでのTCOが必要になる可能性。 |
| Wasm例外処理 | Dart例外からWasm例外へのマッピングあり (暗黙的) **25** | Chrome 119+, Firefox 120+, Safari 18.2+ (WebKit) | JITコードのエラー処理を改善。Dart例外との相互運用性。 |
| 型付き関数参照 | 不明/未確認 (Dart関数オブジェクトの直接マッピング) | Chrome 96+, Firefox 79+, Safari 15+ | Clojure関数呼び出しのパフォーマンスと型安全性を向上させる可能性。 |
| コンポーネントモデル | 提案/初期段階 **26** | 進行中 (WASI 0.2.0は安定版) **52** | 将来的な相互運用性のための考慮事項。初期バージョンでは必須ではない。 |

## **7. パフォーマンス、最適化、およびデバッグ戦略**

### **7.1. 高速なロード時間と実行速度の達成**

ランタイムサイズを最小化する：Dartベースのランタイムには、ツリーシェイキング（Hootのように **6**）が重要となる。`dart2wasm`は最適化のためにBinaryenを使用しており **17**、これが役立つ可能性がある。高速起動：DartランタイムのWasmへのAOTコンパイル。Flutter Webの`skwasm`レンダラはWasmでより良い起動時間を示している **46**。しかし、大規模アプリでは初期ロードが依然として大きい可能性がある **55**。効率的なJIT：ランタイム内のClojure-to-Wasm JIT自体が高速でなければならない。「リンキングJIT」アプローチ（事前コンパイルされたWasm片をアセンブルする）は、ゼロからの完全なWasm生成よりも高速である可能性がある。Jankからの教訓：ネイティブパフォーマンスのためのLLVMベースのJITおよびAOT **30**。直接Wasmではないが、パフォーマンスの追求は関連性がある。WasmGCは、カスタムGCをWasmモジュールと共に配布するよりも一般的に効率的である **18**。

パフォーマンスは多面的である：ランタイムロード時間、JITコンパイル速度、およびJITコンパイルされたClojureコードの実行速度。それぞれに対処する必要がある。「スクリプト言語の速度」と「高速なランタイムロード」というユーザーの目標は、あらゆるレベルでの慎重な最適化を必要とする。Wasmはネイティブに近い速度を目指しているが、Wasm（Dartからコンパイル）内からWasmにJITコンパイルするClojureランタイムは、複数のレイヤー（Clojure -> Dart表現 -> `dart2wasm` -> ホストWasm VM -> JITロジック -> Clojureコード用の新しいWasm -> ホストWasm VM）を導入する。各レイヤーはオーバーヘッドを追加する可能性がある。「スクリプト言語並みの速さ」を達成するには、JITでの積極的な最適化と、「Wasmコード片」を可能な限り最適なWasmに近づける慎重な設計が必要となる。ユーザーのアーキテクチャは革新的であるが、固有の階層化がある。JITコンパイルされたClojureコードのパフォーマンスは、それが生成するWasmの品質だけでなく、JITコンパイラ自体（Dartで書かれ、Wasmとして実行される）の効率とDart-Wasmランタイムのオーバーヘッドにも依存する。これは、言語をWasmにAOTコンパイルするよりも複雑である。

### **7.2. Dartコンパイル済みWasmのデバッグ**

ブラウザ（Chrome、Firefox）にはWasmデバッグサポート（ブレークポイント、ステップ実行、変数検査）がある **57**。ソースマップは、コンパイルされたWasmを元のソース（この場合はDart、または多層ソースマップが生成できればClojureさえも）にマッピングするために不可欠である **57**。Dart DevToolsはウェブアプリをデバッグでき、そのWasmデバッグとの統合を理解する必要がある **57**。`webdev serve --debug`は一般的なコマンドである。Sentryはクラッシュレポート用にWasmデバッグファイルをサポートしている **59**。

Wasm、特にWasmによってJITコンパイルされたコードのデバッグは困難となるだろう。`dart2wasm`からの良好なソースマップサポートは、Dartランタイムのデバッグに不可欠である。JIT生成されたClojure-Wasmのデバッグはさらに困難になるだろう。初期には、これは生のWasmまたはIRの検査を伴う可能性がある。デバッグは重大な課題となるだろう。`dart2wasm`はDartランタイムコード用のソースマップを提供するかもしれないが **57**、実行時にClojureコードからJIT生成されたWasmをデバッグすることは、初期にはClojureへの直接的なソースマッピングを欠く可能性が高い。これには、JIT生成されたWasmのための堅牢な内部ロギング、IRダンプ、および潜在的にカスタムデバッグツールが必要となる。標準的なデバッグツールは、コンパイルされた出力を元のソースにマップする。ここで、JIT生成されたWasmの「元のソース」は、実行時に処理されるClojureコードである。この動的に生成されたWasmからClojureへのソースマップをオンザフライで作成することは、JITに組み込む必要がある高度なコンパイラ機能である。それがなければ、デバッグはIRまたは生のJIT生成Wasmを見ることになる。

### **7.3. Wasm上の動的言語インタプリタのパフォーマンス分析**

Wasmにコンパイルされたインタプリタは、複数層の解釈/JITコンパイルによりパフォーマンスが低下する可能性がある **61**。WasmGCは、言語がホストのGCを使用できるようにすることで役立ち、潜在的に非効率なGCを配布することを回避する **18**。Wasm上の解釈型言語のボトルネックには、WasmとJS間の頻繁な相互作用（もしあれば）、およびWasmの線形メモリまたはWasmGC型にうまくマッピングされていない場合の複雑なデータ構造の非効率な処理が含まれる可能性がある **34**。Shopifyによる論文 **64** は、既存のJSインタプリタ（SpiderMonkey）とLuaインタプリタをWasm用に部分評価で特化することにより、それぞれ2.17倍と1.84倍の速度向上を示している。これは、Wasm上のインタプリタの最適化の可能性を示している。プロファイリング用のWASMインストルメンテーションはオーバーヘッドを持つ可能性がある **65**。

本プロジェクトは単なる解釈ではなくJITコンパイルを目指しており、これによりWasmにコンパイルされた単純なインタプリタループよりも優れたパフォーマンスが得られるはずである。しかし、JITコンパイラ自体がWasm上で実行されるコードであるため、その効率も要因となる。インタプリタの最適化からの洞察（**64**など）は、JITのコード生成戦略の最適化に部分的に適用できる可能性がある。

## **8. 類似の取り組みとの比較分析**

### **8.1. Jank (C++/LLVM上のClojure風言語)**

Jankは、C++とLLVM JIT/AOTを介してネイティブパフォーマンスでClojure互換性を目指している **30**。特徴：コードアズデータ、マクロ、永続不変データ構造、STM、REPLベース開発。Clojure JVMとはC++ホストとLLVM JITにおいて異なり、C++相互運用を可能にする **56**。最小ランタイムと高速起動のためのAOTコンパイル **30**。

Jankは、ClojureセマンティクスをJVMから切り離し、高いパフォーマンスを達成できることを示す重要な精神的前身である。そのLLVMの使用は、Wasmが多くの言語にとってLLVMターゲットであるため関連性がある。Jankのネイティブ相互運用と最小ランタイムのためのAOTコンパイルへのアプローチは、Clojure-Wasmエクスペリエンスを最適化するための貴重な教訓を提供する。ユーザーのプロジェクトにとっての課題は、JITの「ネイティブ」ターゲットがJankのようなマシンコードではなくWasm自体であることである。JankのJVM競合パフォーマンスの追求（LLVM経由 **30**）は高いハードルを設定し、Clojure-on-Dart-to-Wasm JITには大幅なコンパイラ最適化作業が必要であることを示唆している。ターゲット（Wasm対ネイティブマシンコード）は異なるが、コンパイラ/JITにおける積極的な最適化の原則は移転可能である。Jankのアーキテクチャ（C++/LLVM）は生のパフォーマンスのために設計されている。Wasm上で同等の「スクリプト言語の速度」を達成するためには、ユーザーのJITがClojureコードから効率的なWasmを生成する上で非常に効果的である必要があり、基礎となるDart-Wasmランタイムは軽量でなければならない。

### **8.2. clj.wasm プロジェクト**

目標：ClojureのターゲットとしてのWasmを探求し、WasmGCを活用する **67**。計画には、WasmGC機能の探求、ClojureScriptコンパイラのWAT発行への変換の可能性、Clojureのデータ構造のWasmGCへの移植、Wasmコンポーネントとの統合、動的再コンパイル/再リンク（`eval`）の実装が含まれる **67**。

`clj.wasm`は非常に類似した高レベルの目標を共有している。その計画 **69** である「Clojureの不変データ構造をWasmGCに移植する」および「動的再コンパイル/再リンク（eval / JIR）を実装する」は、ユーザーの目的と直接重複する。このプロジェクトを監視することで、洞察が得られたり、共通の課題が特定されたりする可能性がある。ClojureScriptコンパイラを変換するというアイデアは、ユーザーが取っていない代替パスである（中間ステップ/ホストとしてJSの代わりにDartを選択している）。`clj.wasm`がClojureScriptのコンパイラを移植するか、データ構造のために直接WasmGCをターゲットにする可能性のある計画 **69** は、Clojure -> Dart -> Wasmよりも直接的なパスを強調している。ユーザーのDartの選択はWasmGC統合のための戦略的なものであるが、仮説的な直接Clojure-to-Wasmコンパイラと比較して余分なレイヤーを導入する。Dartからの「Wasmコード片」は、このレイヤーを正当化するために非常に効率的でなければならない。`clj.wasm`は、Clojure/ClojureScriptからWasmへのより直接的なコンパイルを探求しているように思われる。ユーザーのDart中心のアプローチはDartのWasmGCサポートを活用するが、ClojureセマンティクスがまずDartで表現され、次にDartがWasmにコンパイルされることを意味する。この「高レベルWasmジェネレータとしてのDart」の効率が鍵となる。もしDartがClojure操作のために高度に最適化された「Wasmコード片」を生成できない場合、Dartレイヤーのオーバーヘッドは、より直接的なClojure-to-Wasmコンパイラと比較してボトルネックになる可能性がある。

## **9. 結論と戦略的推奨事項**

### **9.1. 最も実行可能なパスと重要な考慮事項の概要**

ランタイムClojure-to-Wasmコンパイルのための最も実行可能なアプローチとして、「リンキングJIT」アプローチ（Dartから事前コンパイルされたWasm片をアセンブルする）を再確認する。Dartの再帰パターンに対する`dart2wasm`のTCOの挙動を検証し、必要に応じてClojure用のコンパイラレベルTCOを計画するという重要な必要性を強調する。WasmGC効率のためのClojureデータ構造のDart表現の慎重な設計の重要性を強調する。

ユーザーの要求の最も複雑で斬新な部分は、Clojureコードの新しいWasmモジュールへのランタイムJITコンパイルであり、これはすべて、それ自体がWasmにコンパイルされたDartコードであるプライマリランタイム内で発生する。「Wasmコード片」というアイデアは、プリミティブ用のWasm生成の負担を`dart2wasm`（AOT）にシフトし、ランタイムJITをより「リンキング」または「構成」JITにすることで、これを扱いやすくする鍵となる。実行時にWasmサンドボックス内からゼロから任意のWasmを生成することは非常に困難である。これにはWasmコンパイラ/アセンブラの埋め込みが必要となる。Clojureプリミティブを実装するDart関数を`dart2wasm`を使用してWasm関数に事前コンパイルすることにより、ランタイムJITはClojureのパース、マクロ展開、そしてこれらの既存のWasm関数の呼び出しの選択と配置に集中できる。これは、この環境におけるJITコンパイルのより制約された、しかしはるかに達成可能な形式である。

### **9.2. 開発と主要マイルストーンのための段階的アプローチ**

- **フェーズ1：コアランタイム（AOTフォーカス）。**
  - コアClojureデータ構造（に触発された）とClojure関数のサブセットのDart実装を開発する。

        **32**

  - DartでClojureパーサーを作成する。
  - これらの構造上で動作するDartにおけるClojureインタプリタを実装する。
  - このDartベースのClojureインタプリタ全体を`dart2wasm`を使用してWasmモジュールにコンパイルする。
  - *マイルストーン：* 基本的なClojureサブセットがWasmで解釈的に実行される。
- **フェーズ2：初期JIT（事前コンパイル済みWasm片のリンキング）。**
  - パフォーマンスクリティカルなClojureプリミティブを特定する。
  - それらのDart実装が`dart2wasm`を介して効率的な「Wasmコード片」にコンパイルされることを確認する。
  - これらのプリミティブに対して、解釈する代わりにこれらのAOTコンパイル済みWasm関数を呼び出すようにインタプリタを変更する。
  - `eval`メカニズムを開発して、パース、マクロ展開（マクロ関数用にフェーズ1のインタプリタを使用）、そしてこれらのWasm片を「リンク」する。
  - *マイルストーン：* `eval`がAOTコンパイル済みWasm関数を構成することによりClojureコードを実行できる。
- **フェーズ3：最適化と拡張。**
  - Clojure用の堅牢なTCOを実装する（`dart2wasm`出力を検証するか、IR変換によって）。
  - データ構造とJITリンキングを最適化する。
  - サポートされるClojureサブセットを拡張する。
  - 「リンキングJIT」が不十分であると判明した場合、Dartからのより高度なWasm生成を調査する。
  - *マイルストーン：* Wasm上のパフォーマンスが高く、より完全なClojureランタイム。

プロジェクトの野心は、初期インタプリタ（WasmにコンパイルされたDart）が徐々にJITコンパイラに進化する反復的なアプローチを必要とする。これにより、早期の検証と、マクロ展開、TCO、効率的なデータ構造表現などの複雑な問題への段階的な取り組みが可能になる。ゼロから完全なJITコンパイラを直接構築することは膨大な作業である。インタプリタから始めることで、コア言語セマンティクスとデータ構造を実装しテストすることができる。その後、インタプリタのパフォーマンスボトルネックを特定し、「事前コンパイル済み片のリンキング」戦略を使用して、JITコンパイルされたWasmコードで段階的に置き換えることができる。これにより、プロジェクトのリスクが軽減される。

本報告書で概説した戦略と考慮事項は、Clojureの動的な能力とWasmのパフォーマンスの可能性を組み合わせた、野心的かつ革新的な処理系の開発に向けた強固な基盤を提供するものである。成功には、慎重な段階的実装、Wasmエコシステムの進化の継続的な評価、およびパフォーマンスとデバッグに関する課題への集中的な取り組みが必要となるだろう。
